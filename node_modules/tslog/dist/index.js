"use strict";
/**
 * Expressive TypeScript Logger for Node.js
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const os_1 = require("os");
const path_1 = require("path");
const util_1 = require("util");
const source_map_support_1 = require("source-map-support");
const LoggerHelper_1 = require("./LoggerHelper");
/**
 * 📝 Expressive TypeScript Logger for Node.js
 * @public
 */
class Logger {
    /**
     * @param settings - Configuration of the logger instance  (all settings are optional with sane defaults)
     */
    constructor(settings, parentSettings) {
        this._logLevels = [
            "silly",
            "trace",
            "debug",
            "info",
            "warn",
            "error",
            "fatal",
        ];
        this._ignoreStackLevels = 3;
        this._attachedTransports = [];
        this._minLevelToStdErr = 4;
        this._mySettings = {};
        this._childLogger = [];
        this._parentOrDefaultSettings = {
            type: "pretty",
            instanceName: os_1.hostname(),
            name: undefined,
            setCallerAsLoggerName: false,
            requestId: undefined,
            minLevel: "silly",
            exposeStack: false,
            exposeErrorCodeFrame: true,
            exposeErrorCodeFrameLinesBeforeAndAfter: 5,
            suppressStdOutput: false,
            overwriteConsole: false,
            logLevelsColors: {
                0: "whiteBright",
                1: "white",
                2: "greenBright",
                3: "blueBright",
                4: "yellowBright",
                5: "redBright",
                6: "magentaBright",
            },
            prettyInspectHighlightStyles: {
                special: "cyan",
                number: "green",
                bigint: "green",
                boolean: "yellow",
                undefined: "red",
                null: "red",
                string: "red",
                symbol: "green",
                date: "magenta",
                name: "white",
                regexp: "red",
                module: "underline",
            },
            prettyInspectOptions: {
                colors: true,
                compact: false,
                depth: Infinity,
            },
            jsonInspectOptions: {
                colors: false,
                compact: true,
                depth: Infinity,
            },
            dateTimePattern: "year-month-day hour:minute:second.millisecond",
            // local timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
            dateTimeTimezone: "utc",
            prefix: [],
            maskValuesOfKeys: ["password"],
            maskStrings: [],
            maskPlaceholder: "[***]",
            printLogMessageInNewLine: false,
            // display settings
            displayDateTime: true,
            displayLogLevel: true,
            displayInstanceName: false,
            displayLoggerName: true,
            displayRequestId: true,
            displayFilePath: "hideNodeModulesOnly",
            displayFunctionName: true,
            displayTypes: false,
            stdOut: process.stdout,
            stdErr: process.stderr,
        };
        const mySettings = settings != null ? settings : {};
        this.setSettings(mySettings, parentSettings);
        LoggerHelper_1.LoggerHelper.initErrorToJsonHelper();
    }
    /** Readonly settings of the current logger instance. Used for testing. */
    get settings() {
        const myPrefix = this._mySettings.prefix != null ? this._mySettings.prefix : [];
        return {
            ...this._parentOrDefaultSettings,
            ...this._mySettings,
            prefix: [...this._parentOrDefaultSettings.prefix, ...myPrefix],
        };
    }
    /**
     *  Change settings during runtime
     *  Changes will be propagated to potential child loggers
     *
     * @param settings - Settings to overwrite with. Only this settings will be overwritten, rest will remain the same.
     * @param parentSettings - INTERNAL USE: Is called by a parent logger to propagate new settings.
     */
    setSettings(settings, parentSettings) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this._mySettings = {
            ...this._mySettings,
            ...settings,
        };
        this._mySettings.name = (_a = this._mySettings.name) !== null && _a !== void 0 ? _a : (this._mySettings.setCallerAsLoggerName
            ? (_g = (_d = (_c = (_b = LoggerHelper_1.LoggerHelper.getCallSites()) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.getTypeName()) !== null && _d !== void 0 ? _d : (_f = (_e = LoggerHelper_1.LoggerHelper.getCallSites()) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.getFunctionName()) !== null && _g !== void 0 ? _g : undefined : undefined);
        if (parentSettings != null) {
            this._parentOrDefaultSettings = {
                ...this._parentOrDefaultSettings,
                ...parentSettings,
            };
        }
        this._maskValuesOfKeysRegExp =
            ((_h = this.settings.maskValuesOfKeys) === null || _h === void 0 ? void 0 : _h.length) > 0
                ? new RegExp("^(.*)(" +
                    Object.values(this.settings.maskValuesOfKeys).join("|") +
                    ").*(\\,)$", "gim")
                : undefined;
        this._maskStringsRegExp =
            ((_j = this.settings.maskStrings) === null || _j === void 0 ? void 0 : _j.length) > 0
                ? new RegExp(Object.values(this.settings.maskStrings).join("|"), "g")
                : undefined;
        LoggerHelper_1.LoggerHelper.setUtilsInspectStyles(this.settings.prettyInspectHighlightStyles);
        if (this.settings.overwriteConsole) {
            LoggerHelper_1.LoggerHelper.overwriteConsole(this, this._handleLog);
        }
        this._childLogger.forEach((childLogger) => {
            childLogger.setSettings({}, this.settings);
        });
        return this.settings;
    }
    /**
     *  Returns a child logger based on the current instance with inherited settings
     *
     * @param settings - Overwrite settings inherited from parent logger
     */
    getChildLogger(settings) {
        const childSettings = {
            ...this.settings,
        };
        const childLogger = new Logger(settings, childSettings);
        this._childLogger.push(childLogger);
        return childLogger;
    }
    /**
     *  Attaches external Loggers, e.g. external log services, file system, database
     *
     * @param transportLogger - External logger to be attached. Must implement all log methods.
     * @param minLevel        - Minimum log level to be forwarded to this attached transport logger. (e.g. debug)
     */
    attachTransport(transportLogger, minLevel = "silly") {
        this._attachedTransports.push({
            minLevel,
            transportLogger,
        });
    }
    /**
     * Logs a silly message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    silly(...args) {
        return this._handleLog.apply(this, ["silly", args]);
    }
    /**
     * Logs a trace message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    trace(...args) {
        return this._handleLog.apply(this, ["trace", args, true]);
    }
    /**
     * Logs a debug message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    debug(...args) {
        return this._handleLog.apply(this, ["debug", args]);
    }
    /**
     * Logs an info message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    info(...args) {
        return this._handleLog.apply(this, ["info", args]);
    }
    /**
     * Logs a warn message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    warn(...args) {
        return this._handleLog.apply(this, ["warn", args]);
    }
    /**
     * Logs an error message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    error(...args) {
        return this._handleLog.apply(this, ["error", args]);
    }
    /**
     * Logs a fatal message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    fatal(...args) {
        return this._handleLog.apply(this, ["fatal", args]);
    }
    /**
     * Helper: Pretty print error without logging it
     * @param error - Error object
     * @param print - Print the error or return only? (default: true)
     * @param exposeErrorCodeFrame  - Should the code frame be exposed? (default: true)
     * @param exposeStackTrace  - Should the stack trace be exposed? (default: true)
     * @param stackOffset - Offset lines of the stack trace (default: 0)
     * @param stackLimit  - Limit number of lines of the stack trace (default: Infinity)
     * @param std - Which std should the output be printed to? (default: stdErr)
     */
    prettyError(error, print = true, exposeErrorCodeFrame = true, exposeStackTrace = true, stackOffset = 0, stackLimit = Infinity, std = this.settings.stdErr) {
        const errorObject = this._buildErrorObject(error, exposeErrorCodeFrame, stackOffset, stackLimit);
        if (print) {
            this._printPrettyError(std, errorObject, exposeStackTrace);
        }
        return errorObject;
    }
    _handleLog(logLevel, logArguments, exposeStack = this.settings.exposeStack) {
        const logObject = this._buildLogObject(logLevel, logArguments, exposeStack);
        if (!this.settings.suppressStdOutput &&
            logObject.logLevelId >= this._logLevels.indexOf(this.settings.minLevel)) {
            if (this.settings.type === "pretty") {
                this._printPrettyLog(logObject);
            }
            else if (this.settings.type === "json") {
                this._printJsonLog(logObject);
            }
            else {
                // don't print (e.g. "hidden")
            }
        }
        this._attachedTransports.forEach((transport) => {
            if (logObject.logLevelId >=
                Object.values(this._logLevels).indexOf(this.settings.minLevel)) {
                transport.transportLogger[logLevel](logObject);
            }
        });
        return logObject;
    }
    _buildLogObject(logLevel, logArguments, exposeStack = true) {
        const callSites = LoggerHelper_1.LoggerHelper.getCallSites();
        const relevantCallSites = callSites.splice(this._ignoreStackLevels);
        const stackFrame = source_map_support_1.wrapCallSite(relevantCallSites[0]);
        const stackFrameObject = LoggerHelper_1.LoggerHelper.toStackFrameObject(stackFrame);
        const requestId = this.settings.requestId instanceof Function
            ? this.settings.requestId()
            : this.settings.requestId;
        const logObject = {
            instanceName: this.settings.instanceName,
            loggerName: this.settings.name,
            hostname: os_1.hostname(),
            requestId,
            date: new Date(),
            logLevel: logLevel,
            logLevelId: this._logLevels.indexOf(logLevel),
            filePath: stackFrameObject.filePath,
            fullFilePath: stackFrameObject.fullFilePath,
            fileName: stackFrameObject.fileName,
            lineNumber: stackFrameObject.lineNumber,
            columnNumber: stackFrameObject.columnNumber,
            isConstructor: stackFrameObject.isConstructor,
            functionName: stackFrameObject.functionName,
            typeName: stackFrameObject.typeName,
            methodName: stackFrameObject.methodName,
            argumentsArray: [],
            toJSON: () => this._logObjectToJson(logObject),
        };
        const logArgumentsWithPrefix = [
            ...this.settings.prefix,
            ...logArguments,
        ];
        logArgumentsWithPrefix.forEach((arg) => {
            if (arg != null && typeof arg === "object" && LoggerHelper_1.LoggerHelper.isError(arg)) {
                logObject.argumentsArray.push(this._buildErrorObject(arg, this.settings.exposeErrorCodeFrame));
            }
            else {
                logObject.argumentsArray.push(arg);
            }
        });
        if (exposeStack) {
            logObject.stack = this._toStackObjectArray(relevantCallSites);
        }
        return logObject;
    }
    _buildErrorObject(error, exposeErrorCodeFrame = true, stackOffset = 0, stackLimit = Infinity) {
        var _a, _b;
        const errorCallSites = LoggerHelper_1.LoggerHelper.getCallSites(error);
        stackOffset = stackOffset > -1 ? stackOffset : 0;
        const relevantCallSites = (_a = ((errorCallSites === null || errorCallSites === void 0 ? void 0 : errorCallSites.splice) && errorCallSites.splice(stackOffset))) !== null && _a !== void 0 ? _a : [];
        stackLimit = stackLimit > -1 ? stackLimit : 0;
        if (stackLimit < Infinity) {
            relevantCallSites.length = stackLimit;
        }
        const errorObject = JSON.parse(JSON.stringify(error));
        errorObject.nativeError = error;
        errorObject.details = { ...error };
        errorObject.name = (_b = errorObject.name) !== null && _b !== void 0 ? _b : "Error";
        errorObject.isError = true;
        errorObject.stack = this._toStackObjectArray(relevantCallSites);
        if (errorObject.stack.length > 0) {
            const errorCallSite = LoggerHelper_1.LoggerHelper.toStackFrameObject(source_map_support_1.wrapCallSite(relevantCallSites[0]));
            if (exposeErrorCodeFrame && errorCallSite.lineNumber != null) {
                if (errorCallSite.fullFilePath.indexOf("node_modules") < 0) {
                    errorObject.codeFrame = LoggerHelper_1.LoggerHelper._getCodeFrame(errorCallSite.fullFilePath, errorCallSite.lineNumber, errorCallSite.columnNumber, this.settings.exposeErrorCodeFrameLinesBeforeAndAfter);
                }
            }
        }
        return errorObject;
    }
    _toStackObjectArray(jsStack) {
        const stackFrame = Object.values(jsStack).reduce((stackFrameObj, callsite) => {
            stackFrameObj.push(LoggerHelper_1.LoggerHelper.toStackFrameObject(source_map_support_1.wrapCallSite(callsite)));
            return stackFrameObj;
        }, []);
        return stackFrame;
    }
    _printPrettyLog(logObject) {
        const std = logObject.logLevelId < this._minLevelToStdErr
            ? this.settings.stdOut
            : this.settings.stdErr;
        if (this.settings.displayDateTime === true) {
            const dateTimeParts = [
                ...new Intl.DateTimeFormat("en", {
                    weekday: undefined,
                    year: "numeric",
                    month: "2-digit",
                    day: "2-digit",
                    hour12: false,
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit",
                    timeZone: this.settings.dateTimeTimezone,
                }).formatToParts(logObject.date),
                {
                    type: "millisecond",
                    value: logObject.date.getMilliseconds().toString(),
                },
            ];
            const nowStr = dateTimeParts.reduce((prevStr, thisStr) => prevStr.replace(thisStr.type, thisStr.value), this.settings.dateTimePattern);
            std.write(LoggerHelper_1.LoggerHelper.styleString(["gray"], `${nowStr}\t`));
        }
        if (this.settings.displayLogLevel) {
            const colorName = this.settings.logLevelsColors[logObject.logLevelId];
            std.write(LoggerHelper_1.LoggerHelper.styleString([colorName, "bold"], ` ${logObject.logLevel.toUpperCase()} `) + "\t");
        }
        const loggerName = this.settings.displayLoggerName === true && logObject.loggerName != null
            ? logObject.loggerName
            : "";
        const instanceName = this.settings.displayInstanceName === true &&
            this.settings.instanceName != null
            ? `@${this.settings.instanceName}`
            : "";
        const traceId = this.settings.displayRequestId === true && logObject.requestId != null
            ? `:${logObject.requestId}`
            : "";
        const name = (loggerName + instanceName + traceId).length > 0
            ? loggerName + instanceName + traceId
            : "";
        const functionName = this.settings.displayFunctionName === true
            ? logObject.isConstructor
                ? ` ${logObject.typeName}.constructor`
                : logObject.methodName != null
                    ? ` ${logObject.typeName}.${logObject.methodName}`
                    : logObject.functionName != null
                        ? ` ${logObject.functionName}`
                        : ""
            : "";
        let fileLocation = "";
        if (this.settings.displayFilePath === "displayAll" ||
            (this.settings.displayFilePath === "hideNodeModulesOnly" &&
                logObject.filePath.indexOf("node_modules") < 0)) {
            fileLocation = `${logObject.filePath}:${logObject.lineNumber}`;
        }
        const concatenatedMetaLine = [name, fileLocation, functionName]
            .join(" ")
            .replace(/\s\s+/g, " ")
            .trim();
        if (concatenatedMetaLine.length > 0) {
            std.write(LoggerHelper_1.LoggerHelper.styleString(["gray"], `[${concatenatedMetaLine}]`) + "  \t");
            if (this.settings.printLogMessageInNewLine === false) {
                std.write("  \t");
            }
            else {
                std.write("\n");
            }
        }
        logObject.argumentsArray.forEach((argument) => {
            const typeStr = this.settings.displayTypes === true
                ? LoggerHelper_1.LoggerHelper.styleString(["grey", "bold"], typeof argument + ":") +
                    " "
                : "";
            const errorObject = argument;
            if (typeof argument === "object" && (errorObject === null || errorObject === void 0 ? void 0 : errorObject.isError) === true) {
                this._printPrettyError(std, errorObject);
            }
            else if (typeof argument === "object" &&
                (errorObject === null || errorObject === void 0 ? void 0 : errorObject.isError) !== true) {
                std.write("\n" +
                    typeStr +
                    this._inspectAndHideSensitive(argument, this.settings.prettyInspectOptions));
            }
            else {
                std.write(typeStr + this._formatAndHideSesitive(argument) + " ");
            }
        });
        std.write("\n");
        if (logObject.stack != null) {
            std.write(LoggerHelper_1.LoggerHelper.styleString(["underline", "bold"], "log stack:\n"));
            this._printPrettyStack(std, logObject.stack);
        }
    }
    _printPrettyError(std, errorObject, printStackTrace = true) {
        var _a;
        std.write("\n" +
            LoggerHelper_1.LoggerHelper.styleString(["bgRed", "whiteBright", "bold"], ` ${errorObject.name} `) +
            (errorObject.message != null
                ? `\t${this._formatAndHideSesitive(errorObject.message)}`
                : ""));
        if (Object.values(errorObject.details).length > 0) {
            std.write(LoggerHelper_1.LoggerHelper.styleString(["underline", "bold"], "\ndetails:"));
            std.write("\n" +
                this._inspectAndHideSensitive(errorObject.details, this.settings.prettyInspectOptions));
        }
        if (printStackTrace === true && ((_a = errorObject === null || errorObject === void 0 ? void 0 : errorObject.stack) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            std.write(LoggerHelper_1.LoggerHelper.styleString(["underline", "bold"], "\nerror stack:"));
            this._printPrettyStack(std, errorObject.stack);
        }
        if (errorObject.codeFrame != null) {
            this._printPrettyCodeFrame(std, errorObject.codeFrame);
        }
    }
    _printPrettyStack(std, stackObjectArray) {
        std.write("\n");
        Object.values(stackObjectArray).forEach((stackObject) => {
            var _a;
            std.write(LoggerHelper_1.LoggerHelper.styleString(["gray"], "• "));
            if (stackObject.fileName != null) {
                std.write(LoggerHelper_1.LoggerHelper.styleString(["yellowBright"], stackObject.fileName));
            }
            if (stackObject.lineNumber != null) {
                std.write(LoggerHelper_1.LoggerHelper.styleString(["gray"], ":"));
                std.write(LoggerHelper_1.LoggerHelper.styleString(["yellow"], stackObject.lineNumber));
            }
            std.write(LoggerHelper_1.LoggerHelper.styleString(["white"], " " + ((_a = stackObject.functionName) !== null && _a !== void 0 ? _a : "<anonymous>")));
            if (stackObject.filePath != null &&
                stackObject.lineNumber != null &&
                stackObject.columnNumber != null) {
                std.write("\n    ");
                std.write(path_1.normalize(LoggerHelper_1.LoggerHelper.styleString(["gray"], `${stackObject.filePath}:${stackObject.lineNumber}:${stackObject.columnNumber}`)));
            }
            std.write("\n\n");
        });
    }
    _printPrettyCodeFrame(std, codeFrame) {
        std.write(LoggerHelper_1.LoggerHelper.styleString(["underline", "bold"], "code frame:\n"));
        let lineNumber = codeFrame.firstLineNumber;
        codeFrame.linesBefore.forEach((line) => {
            std.write(`  ${LoggerHelper_1.LoggerHelper.lineNumberTo3Char(lineNumber)} | ${line}\n`);
            lineNumber++;
        });
        std.write(LoggerHelper_1.LoggerHelper.styleString(["red"], ">") +
            " " +
            LoggerHelper_1.LoggerHelper.styleString(["bgRed", "whiteBright"], LoggerHelper_1.LoggerHelper.lineNumberTo3Char(lineNumber)) +
            " | " +
            LoggerHelper_1.LoggerHelper.styleString(["yellow"], codeFrame.relevantLine) +
            "\n");
        lineNumber++;
        if (codeFrame.columnNumber != null) {
            const positionMarker = new Array(codeFrame.columnNumber + 8).join(" ") + `^`;
            std.write(LoggerHelper_1.LoggerHelper.styleString(["red"], positionMarker) + "\n");
        }
        codeFrame.linesAfter.forEach((line) => {
            std.write(`  ${LoggerHelper_1.LoggerHelper.lineNumberTo3Char(lineNumber)} | ${line}\n`);
            lineNumber++;
        });
    }
    _logObjectToJson(logObject) {
        return {
            ...logObject,
            argumentsArray: logObject.argumentsArray.map((argument) => {
                const errorObject = argument;
                if (typeof argument === "object" && errorObject.isError) {
                    return {
                        ...errorObject,
                        nativeError: undefined,
                        errorString: this._formatAndHideSesitive(errorObject.nativeError),
                    };
                }
                else if (typeof argument === "object") {
                    return this._inspectAndHideSensitive(argument, this.settings.jsonInspectOptions);
                }
                else {
                    return this._formatAndHideSesitive(argument);
                }
            }),
        };
    }
    _printJsonLog(logObject) {
        const std = logObject.logLevelId < this._minLevelToStdErr
            ? this.settings.stdOut
            : this.settings.stdErr;
        std.write(JSON.stringify(logObject) + "\n");
    }
    _inspectAndHideSensitive(object, options) {
        let inspectedString = util_1.inspect(object, options);
        if (this._maskValuesOfKeysRegExp != null) {
            inspectedString = inspectedString.replace(this._maskValuesOfKeysRegExp, "$1$2: " +
                LoggerHelper_1.LoggerHelper.styleString([this.settings.prettyInspectHighlightStyles.string], `'${this.settings.maskPlaceholder}'`) +
                "$3");
        }
        return this._maskStringsRegExp != null
            ? inspectedString.replace(this._maskStringsRegExp, this.settings.maskPlaceholder)
            : inspectedString;
    }
    _formatAndHideSesitive(formatParam, ...param) {
        const formattedStr = util_1.format(formatParam, ...param);
        return this._maskStringsRegExp != null
            ? formattedStr.replace(this._maskStringsRegExp, this.settings.maskPlaceholder)
            : formattedStr;
    }
}
exports.Logger = Logger;
//# sourceMappingURL=index.js.map