"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCallSites = exports.callsitesSym = void 0;
/* Based on https://github.com/watson/error-callsites */
const callsitesSym = Symbol("callsites");
exports.callsitesSym = callsitesSym;
const fallback = Error.prepareStackTrace;
let lastPrepareStackTrace = fallback;
function prepareStackTrace(err, callsites) {
    var _a, _b;
    // If the symbol has already been set it must mean that someone else has also
    // overwritten `Error.prepareStackTrace` and retains a reference to this
    // function that it's calling every time it's own `prepareStackTrace`
    // function is being called. This would create an infinite loop if not
    // handled.
    if (Object.prototype.hasOwnProperty.call(err, callsitesSym)) {
        return (_a = (fallback && fallback(err, callsites))) !== null && _a !== void 0 ? _a : [];
    }
    Object.defineProperty(err, callsitesSym, {
        enumerable: false,
        configurable: true,
        writable: false,
        value: callsites,
    });
    return (_b = (lastPrepareStackTrace && lastPrepareStackTrace(err, callsites))) !== null && _b !== void 0 ? _b : [];
}
Object.defineProperty(Error, "prepareStackTrace", {
    configurable: true,
    enumerable: true,
    get: function () {
        return prepareStackTrace;
    },
    set: function (fn) {
        // Don't set `lastPrepareStackTrace` to ourselves. If we did, we'd end up
        // throwing a RangeError (Maximum call stack size exceeded).
        lastPrepareStackTrace = fn === prepareStackTrace ? fallback : fn;
    },
});
function getCallSites(err) {
    return err.stack ? err[callsitesSym] : err[callsitesSym];
}
exports.getCallSites = getCallSites;
//# sourceMappingURL=CallSitesHelper.js.map